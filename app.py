from flask import Flask, request, jsonify\nimport subprocess\nimport tempfile\nimport os\nimport signal\nimport time\nimport json\nimport logging\nfrom threading import Timer\nfrom werkzeug.middleware.proxy_fix import ProxyFix\nfrom flask_cors import CORS\nfrom flask_limiter import Limiter\nfrom flask_limiter.util import get_remote_address\n\n# Configure logging\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\napp = Flask(__name__)\napp.wsgi_app = ProxyFix(app.wsgi_app, x_for=1, x_proto=1, x_host=1, x_prefix=1)\n\n# CORS configuration\nCORS(app, origins=[\n    'http://localhost:3000',\n    'http://localhost:3010'\n] if os.getenv('NODE_ENV') != 'production' else [\n    os.getenv('FRONTEND_URLS', '').split(',')\n])\n\n# Rate limiting\nlimiter = Limiter(\n    app,\n    key_func=get_remote_address,\n    default_limits=[\"200 per day\", \"50 per hour\", \"10 per minute\"]\n)\n\n# Configuration\nMAX_EXECUTION_TIME = int(os.getenv('MAX_EXECUTION_TIME', '30'))  # seconds\nMAX_MEMORY_MB = int(os.getenv('MAX_MEMORY_MB', '128))  # MB\nMAX_OUTPUT_SIZE = 50000  # characters\n\nclass ExecutionResult:\n    def __init__(self, stdout: str = \"\", stderr: str = \"\", exit_code: int = 0, \n                 execution_time: float = 0.0, timed_out: bool = False):\n        self.stdout = stdout\n        self.stderr = stderr\n        self.exit_code = exit_code\n        self.execution_time = execution_time\n        self.timed_out = timed_out\n\ndef execute_python_code(code: str, input_data: str = \"\") -> ExecutionResult:\n    \"\"\"Execute Python code in a secure sandboxed environment\"\"\"\n    \n    # Create temporary file for the Python code\n    with tempfile.NamedTemporaryFile(mode='w', suffix='.py', delete=False) as f:\n        f.write(code)\n        temp_file = f.name\n    \n    try:\n        # Prepare the command\n        cmd = [\n            'python3', '-c', f\"\"\"\nimport sys\nimport signal\nimport resource\nimport os\n\n# Set resource limits\nresource.setrlimit(resource.RLIMIT_CPU, ({MAX_EXECUTION_TIME}, {MAX_EXECUTION_TIME}))\nresource.setrlimit(resource.RLIMIT_AS, ({MAX_MEMORY_MB * 1024 * 1024}, {MAX_MEMORY_MB * 1024 * 1024}))\n\n# Disable dangerous modules\nsys.modules['os'] = None\nsys.modules['subprocess'] = None\nsys.modules['socket'] = None\n\ntry:\n    exec(open('{temp_file}').read())\nexcept Exception as e:\n    print(f\"Error: {{e}}\", file=sys.stderr)\n    sys.exit(1)\n\"\"\"\n        ]\n        \n        start_time = time.time()\n        \n        # Execute with timeout\n        try:\n            process = subprocess.Popen(\n                cmd,\n                stdin=subprocess.PIPE,\n                stdout=subprocess.PIPE,\n                stderr=subprocess.PIPE,\n                text=True,\n                preexec_fn=os.setsid  # Create new process group\n            )\n            \n            stdout, stderr = process.communicate(\n                input=input_data, \n                timeout=MAX_EXECUTION_TIME\n            )\n            \n            execution_time = time.time() - start_time\n            \n            # Truncate output if too long\n            if len(stdout) > MAX_OUTPUT_SIZE:\n                stdout = stdout[:MAX_OUTPUT_SIZE] + \"\\n... (output truncated)\"\n            if len(stderr) > MAX_OUTPUT_SIZE:\n                stderr = stderr[:MAX_OUTPUT_SIZE] + \"\\n... (error output truncated)\"\n            \n            return ExecutionResult(\n                stdout=stdout,\n                stderr=stderr,\n                exit_code=process.returncode,\n                execution_time=execution_time\n            )\n            \n        except subprocess.TimeoutExpired:\n            # Kill the process group\n            os.killpg(os.getpgid(process.pid), signal.SIGTERM)\n            execution_time = time.time() - start_time\n            \n            return ExecutionResult(\n                stdout=\"\",\n                stderr=f\"Execution timed out after {MAX_EXECUTION_TIME} seconds\",\n                exit_code=124,\n                execution_time=execution_time,\n                timed_out=True\n            )\n            \n    finally:\n        # Clean up temporary file\n        try:\n            os.unlink(temp_file)\n        except OSError:\n            pass\n\n@app.route('/health', methods=['GET'])\ndef health_check():\n    \"\"\"Health check endpoint\"\"\"\n    return jsonify({\n        'status': 'healthy',\n        'service': 'executor',\n        'timestamp': time.time(),\n        'max_execution_time': MAX_EXECUTION_TIME,\n        'max_memory_mb': MAX_MEMORY_MB\n    })\n\n@app.route('/execute', methods=['POST'])\n@limiter.limit(\"5 per minute\")\ndef execute_code():\n    \"\"\"Execute Python code endpoint\"\"\"\n    try:\n        data = request.get_json()\n        \n        if not data or 'code' not in data:\n            return jsonify({\n                'success': False,\n                'error': 'No code provided'\n            }), 400\n        \n        code = data['code']\n        input_data = data.get('input', '')\n        \n        # Basic code validation\n        if len(code) > 50000:  # 50KB limit\n            return jsonify({\n                'success': False,\n                'error': 'Code too long (max 50KB)'\n            }), 400\n        \n        # Check for dangerous imports/calls\n        dangerous_patterns = [\n            'import os', 'import subprocess', 'import socket',\n            'import urllib', 'import requests', 'import http',\n            '__import__', 'eval', 'exec', 'compile',\n            'open(', 'file(', 'input()'\n        ]\n        \n        code_lower = code.lower()\n        for pattern in dangerous_patterns:\n            if pattern in code_lower:\n                return jsonify({\n                    'success': False,\n                    'error': f'Dangerous operation detected: {pattern}'\n                }), 400\n        \n        # Execute the code\n        result = execute_python_code(code, input_data)\n        \n        return jsonify({\n            'success': True,\n            'output': result.stdout,\n            'error': result.stderr,\n            'exit_code': result.exit_code,\n            'execution_time': result.execution_time,\n            'timed_out': result.timed_out\n        })\n        \n    except Exception as e:\n        logger.error(f\"Execution error: {e}\")\n        return jsonify({\n            'success': False,\n            'error': 'Internal server error'\n        }), 500\n\n@app.errorhandler(404)\ndef not_found(error):\n    return jsonify({'error': 'Not found'}), 404\n\n@app.errorhandler(429)\ndef rate_limit_exceeded(error):\n    return jsonify({'error': 'Rate limit exceeded'}), 429\n\n@app.errorhandler(500)\ndef internal_error(error):\n    return jsonify({'error': 'Internal server error'}), 500\n\nif __name__ == '__main__':\n    port = int(os.getenv('PORT', 5000))\n    debug = os.getenv('NODE_ENV') != 'production'\n    \n    print(f\"üöÄ Executor Server running on port {port}\")\n    print(f\"üåç Environment: {os.getenv('NODE_ENV', 'development')}\")\n    print(f\"‚è±Ô∏è Max execution time: {MAX_EXECUTION_TIME}s\")\n    print(f\"üíæ Max memory: {MAX_MEMORY_MB}MB\")\n    \n    app.run(host='0.0.0.0', port=port, debug=debug)